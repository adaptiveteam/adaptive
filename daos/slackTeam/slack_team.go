package slackTeam
// This file has been automatically generated by `adaptive/scripts`
// The changes will be overridden by the next automatic generation.
import (
	"github.com/aws/aws-sdk-go/aws"
	awsutils "github.com/adaptiveteam/adaptive/aws-utils-go"
	common "github.com/adaptiveteam/adaptive/daos/common"
	core "github.com/adaptiveteam/adaptive/core-utils-go"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/pkg/errors"
	"fmt"
	"encoding/json"
	"strings"
)

type SlackTeam struct  {
	TeamID common.PlatformID `json:"team_id"`
	AccessToken string `json:"access_token,omitempty"`
	TeamName string `json:"team_name,omitempty"`
	// UserID is the ID of the user to send an engagement to
	// This usually corresponds to the platform user id
	UserID string `json:"user_id"`
	EnterpriseID string `json:"enterprise_id,omitempty"`
	BotUserID string `json:"bot_user_id,omitempty"`
	// bot_access_token
	BotAccessToken string `json:"bot_access_token,omitempty"`
	Scopes []string `json:"scopes,omitempty"`
	// Automatically maintained field
	CreatedAt string `json:"created_at"`
	// Automatically maintained field
	ModifiedAt string `json:"modified_at,omitempty"`
}

// CollectEmptyFields returns entity field names that are empty.
// It also returns the boolean ok-flag if the list is empty.
func (slackTeam SlackTeam)CollectEmptyFields() (emptyFields []string, ok bool) {
	if slackTeam.TeamID == "" { emptyFields = append(emptyFields, "TeamID")}
	if slackTeam.UserID == "" { emptyFields = append(emptyFields, "UserID")}
	ok = len(emptyFields) == 0
	return
}
// ToJSON returns json string
func (slackTeam SlackTeam) ToJSON() (string, error) {
	b, err := json.Marshal(slackTeam)
	return string(b), err
}

type DAO interface {
	Create(slackTeam SlackTeam) error
	CreateUnsafe(slackTeam SlackTeam)
	Read(teamID common.PlatformID) (slackTeam SlackTeam, err error)
	ReadUnsafe(teamID common.PlatformID) (slackTeam SlackTeam)
	ReadOrEmpty(teamID common.PlatformID) (slackTeam []SlackTeam, err error)
	ReadOrEmptyUnsafe(teamID common.PlatformID) (slackTeam []SlackTeam)
	CreateOrUpdate(slackTeam SlackTeam) error
	CreateOrUpdateUnsafe(slackTeam SlackTeam)
	Delete(teamID common.PlatformID) error
	DeleteUnsafe(teamID common.PlatformID)
}

// DAOImpl - a container for all information needed to access a DynamoDB table
type DAOImpl struct {
	Dynamo    *awsutils.DynamoRequest `json:"dynamo"`
	Namespace string                  `json:"namespace"`
	Name      string                  `json:"name"`
}

// NewDAO creates an instance of DAO that will provide access to the table
func NewDAO(dynamo *awsutils.DynamoRequest, namespace, clientID string) DAO {
	if clientID == "" { panic(errors.New("Cannot create SlackTeam.DAO without clientID")) }
	return DAOImpl{Dynamo: dynamo, Namespace: namespace, 
		Name: TableName(clientID),
	}
}

// NewDAOByTableName creates an instance of DAO that will provide access to the table
func NewDAOByTableName(dynamo *awsutils.DynamoRequest, namespace, tableName string) DAO {
	if tableName == "" { panic(errors.New("Cannot create SlackTeam.DAO without tableName")) }
	return DAOImpl{Dynamo: dynamo, Namespace: namespace, 
		Name: tableName,
	}
}
// TableNameSuffixVar is a global variable that contains table name suffix.
// After renaming all tables this may be made `const`.
var TableNameSuffixVar = "_slack_team"

// TableName concatenates table name prefix and suffix and returns table name
func TableName(prefix string) string {
	return prefix + TableNameSuffixVar
}

// Create saves the SlackTeam.
func (d DAOImpl) Create(slackTeam SlackTeam) (err error) {
	emptyFields, ok := slackTeam.CollectEmptyFields()
	if ok {
		slackTeam.ModifiedAt = core.CurrentRFCTimestamp()
	slackTeam.CreatedAt = slackTeam.ModifiedAt
	err = d.Dynamo.PutTableEntry(slackTeam, d.Name)
	} else {
		err = fmt.Errorf("Cannot create entity with empty fields: %v", emptyFields)
	}
	return
}


// CreateUnsafe saves the SlackTeam.
func (d DAOImpl) CreateUnsafe(slackTeam SlackTeam) {
	err2 := d.Create(slackTeam)
	core.ErrorHandler(err2, d.Namespace, fmt.Sprintf("Could not create teamID==%s in %s\n", slackTeam.TeamID, d.Name))
}


// Read reads SlackTeam
func (d DAOImpl) Read(teamID common.PlatformID) (out SlackTeam, err error) {
	var outs []SlackTeam
	outs, err = d.ReadOrEmpty(teamID)
	if err == nil && len(outs) == 0 {
		err = fmt.Errorf("Not found teamID==%s in %s\n", teamID, d.Name)
	}
	if len(outs) > 0 {
		out = outs[0]
	}
	return
}


// ReadUnsafe reads the SlackTeam. Panics in case of any errors
func (d DAOImpl) ReadUnsafe(teamID common.PlatformID) SlackTeam {
	out, err2 := d.Read(teamID)
	core.ErrorHandler(err2, d.Namespace, fmt.Sprintf("Error reading teamID==%s in %s\n", teamID, d.Name))
	return out
}


// ReadOrEmpty reads SlackTeam
func (d DAOImpl) ReadOrEmpty(teamID common.PlatformID) (out []SlackTeam, err error) {
	var outOrEmpty SlackTeam
	ids := idParams(teamID)
	var found bool
	found, err = d.Dynamo.GetItemOrEmptyFromTable(d.Name, ids, &outOrEmpty)
	if found {
		if outOrEmpty.TeamID == teamID {
			out = append(out, outOrEmpty)
		} else {
			err = fmt.Errorf("Requested ids: teamID==%s are different from the found ones: teamID==%s", teamID, outOrEmpty.TeamID) // unexpected error: found ids != ids
		}
	}
	err = errors.Wrapf(err, "SlackTeam DAO.ReadOrEmpty(id = %v) couldn't GetItem in table %s", ids, d.Name)
	return
}


// ReadOrEmptyUnsafe reads the SlackTeam. Panics in case of any errors
func (d DAOImpl) ReadOrEmptyUnsafe(teamID common.PlatformID) []SlackTeam {
	out, err2 := d.ReadOrEmpty(teamID)
	core.ErrorHandler(err2, d.Namespace, fmt.Sprintf("Error while reading teamID==%s in %s\n", teamID, d.Name))
	return out
}


// CreateOrUpdate saves the SlackTeam regardless of if it exists.
func (d DAOImpl) CreateOrUpdate(slackTeam SlackTeam) (err error) {
	slackTeam.ModifiedAt = core.CurrentRFCTimestamp()
	if slackTeam.CreatedAt == "" { slackTeam.CreatedAt = slackTeam.ModifiedAt }
	
	var olds []SlackTeam
	olds, err = d.ReadOrEmpty(slackTeam.TeamID)
	err = errors.Wrapf(err, "SlackTeam DAO.CreateOrUpdate(id = teamID==%s) couldn't ReadOrEmpty", slackTeam.TeamID)
	if err == nil {
		if len(olds) == 0 {
			err = d.Create(slackTeam)
			err = errors.Wrapf(err, "SlackTeam DAO.CreateOrUpdate couldn't Create in table %s", d.Name)
		} else {
			emptyFields, ok := slackTeam.CollectEmptyFields()
			if ok {
				old := olds[0]
				slackTeam.CreatedAt  = old.CreatedAt
				slackTeam.ModifiedAt = core.CurrentRFCTimestamp()
				key := idParams(old.TeamID)
				expr, exprAttributes, names := updateExpression(slackTeam, old)
				input := dynamodb.UpdateItemInput{
					ExpressionAttributeValues: exprAttributes,
					TableName:                 aws.String(d.Name),
					Key:                       key,
					ReturnValues:              aws.String("UPDATED_NEW"),
					UpdateExpression:          aws.String(expr),
				}
				if names != nil { input.ExpressionAttributeNames = *names } // workaround for a pointer to an empty slice
				if  len(exprAttributes) > 0 { // if there some changes
					err = d.Dynamo.UpdateItemInternal(input)
				} else {
					// WARN: no changes.
				}
				err = errors.Wrapf(err, "SlackTeam DAO.CreateOrUpdate(id = %v) couldn't UpdateTableEntry in table %s, expression='%s'", key, d.Name, expr)
			} else {
				err = fmt.Errorf("Cannot update entity with empty required fields: %v", emptyFields)
			}
		}
	}
	return 
}


// CreateOrUpdateUnsafe saves the SlackTeam regardless of if it exists.
func (d DAOImpl) CreateOrUpdateUnsafe(slackTeam SlackTeam) {
	err2 := d.CreateOrUpdate(slackTeam)
	core.ErrorHandler(err2, d.Namespace, fmt.Sprintf("could not create or update %v in %s\n", slackTeam, d.Name))
}


// Delete removes SlackTeam from db
func (d DAOImpl)Delete(teamID common.PlatformID) error {
	return d.Dynamo.DeleteEntry(d.Name, idParams(teamID))
}


// DeleteUnsafe deletes SlackTeam and panics in case of errors.
func (d DAOImpl)DeleteUnsafe(teamID common.PlatformID) {
	err2 := d.Delete(teamID)
	core.ErrorHandler(err2, d.Namespace, fmt.Sprintf("Could not delete teamID==%s in %s\n", teamID, d.Name))
}

func idParams(teamID common.PlatformID) map[string]*dynamodb.AttributeValue {
	params := map[string]*dynamodb.AttributeValue {
		"team_id": common.DynS(string(teamID)),
	}
	return params
}
func allParams(slackTeam SlackTeam, old SlackTeam) (params map[string]*dynamodb.AttributeValue) {
	params = map[string]*dynamodb.AttributeValue{}
	if slackTeam.TeamID != old.TeamID { params[":a0"] = common.DynS(string(slackTeam.TeamID)) }
	if slackTeam.AccessToken != old.AccessToken { params[":a1"] = common.DynS(slackTeam.AccessToken) }
	if slackTeam.TeamName != old.TeamName { params[":a2"] = common.DynS(slackTeam.TeamName) }
	if slackTeam.UserID != old.UserID { params[":a3"] = common.DynS(slackTeam.UserID) }
	if slackTeam.EnterpriseID != old.EnterpriseID { params[":a4"] = common.DynS(slackTeam.EnterpriseID) }
	if slackTeam.BotUserID != old.BotUserID { params[":a5"] = common.DynS(slackTeam.BotUserID) }
	if slackTeam.BotAccessToken != old.BotAccessToken { params[":a6"] = common.DynS(slackTeam.BotAccessToken) }
	if !common.StringArraysEqual(slackTeam.Scopes, old.Scopes) { params[":a7"] = common.DynSS(slackTeam.Scopes) }
	if slackTeam.CreatedAt != old.CreatedAt { params[":a8"] = common.DynS(slackTeam.CreatedAt) }
	if slackTeam.ModifiedAt != old.ModifiedAt { params[":a9"] = common.DynS(slackTeam.ModifiedAt) }
	return
}
func updateExpression(slackTeam SlackTeam, old SlackTeam) (expr string, params map[string]*dynamodb.AttributeValue, namesPtr *map[string]*string) {
	var updateParts []string
	params = map[string]*dynamodb.AttributeValue{}
	names := map[string]*string{}
	if slackTeam.TeamID != old.TeamID { updateParts = append(updateParts, "team_id = :a0"); params[":a0"] = common.DynS(string(slackTeam.TeamID));  }
	if slackTeam.AccessToken != old.AccessToken { updateParts = append(updateParts, "access_token = :a1"); params[":a1"] = common.DynS(slackTeam.AccessToken);  }
	if slackTeam.TeamName != old.TeamName { updateParts = append(updateParts, "team_name = :a2"); params[":a2"] = common.DynS(slackTeam.TeamName);  }
	if slackTeam.UserID != old.UserID { updateParts = append(updateParts, "user_id = :a3"); params[":a3"] = common.DynS(slackTeam.UserID);  }
	if slackTeam.EnterpriseID != old.EnterpriseID { updateParts = append(updateParts, "enterprise_id = :a4"); params[":a4"] = common.DynS(slackTeam.EnterpriseID);  }
	if slackTeam.BotUserID != old.BotUserID { updateParts = append(updateParts, "bot_user_id = :a5"); params[":a5"] = common.DynS(slackTeam.BotUserID);  }
	if slackTeam.BotAccessToken != old.BotAccessToken { updateParts = append(updateParts, "bot_access_token = :a6"); params[":a6"] = common.DynS(slackTeam.BotAccessToken);  }
	if !common.StringArraysEqual(slackTeam.Scopes, old.Scopes) { updateParts = append(updateParts, "scopes = :a7"); params[":a7"] = common.DynSS(slackTeam.Scopes);  }
	if slackTeam.CreatedAt != old.CreatedAt { updateParts = append(updateParts, "created_at = :a8"); params[":a8"] = common.DynS(slackTeam.CreatedAt);  }
	if slackTeam.ModifiedAt != old.ModifiedAt { updateParts = append(updateParts, "modified_at = :a9"); params[":a9"] = common.DynS(slackTeam.ModifiedAt);  }
	expr = "set " + strings.Join(updateParts, ", ")
	if len(names) == 0 { namesPtr = nil } else { namesPtr = &names } // workaround for ValidationException: ExpressionAttributeNames must not be empty
	return
}
