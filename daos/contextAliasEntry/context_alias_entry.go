package contextAliasEntry
// This file has been automatically generated by `adaptive-platform/scripts`
// The changes will be overridden by the next automatic generation.
import (
	awsutils "github.com/adaptiveteam/aws-utils-go"
	common "github.com/adaptiveteam/daos/common"
	core "github.com/adaptiveteam/core-utils-go"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/pkg/errors"
	"fmt"
	"strings"
)

// ContextAliasEntry contains all of the information needed for a context alias
// A context alias is a way to alias  a piece of context without spelling out
// the context path.  If the path changes you can still safely use the alias.
type ContextAliasEntry struct  {
	ApplicationAlias string `json:"application_alias"`
	Context string `json:"context"`
	BuildID string `json:"build_id"`
}

// CollectEmptyFields returns entity field names that are empty.
// It also returns the boolean ok-flag if the list is empty.
func (contextAliasEntry ContextAliasEntry)CollectEmptyFields() (emptyFields []string, ok bool) {
	if contextAliasEntry.ApplicationAlias == "" { emptyFields = append(emptyFields, "ApplicationAlias")}
	if contextAliasEntry.Context == "" { emptyFields = append(emptyFields, "Context")}
	if contextAliasEntry.BuildID == "" { emptyFields = append(emptyFields, "BuildID")}
	ok = len(emptyFields) == 0
	return
}

type DAO interface {
	Create(contextAliasEntry ContextAliasEntry) error
	CreateUnsafe(contextAliasEntry ContextAliasEntry)
	Read(applicationAlias string) (contextAliasEntry ContextAliasEntry, err error)
	ReadUnsafe(applicationAlias string) (contextAliasEntry ContextAliasEntry)
	ReadOrEmpty(applicationAlias string) (contextAliasEntry []ContextAliasEntry, err error)
	ReadOrEmptyUnsafe(applicationAlias string) (contextAliasEntry []ContextAliasEntry)
	CreateOrUpdate(contextAliasEntry ContextAliasEntry) error
	CreateOrUpdateUnsafe(contextAliasEntry ContextAliasEntry)
	Delete(applicationAlias string) error
	DeleteUnsafe(applicationAlias string)
	ReadByApplicationAlias(applicationAlias string) (contextAliasEntry []ContextAliasEntry, err error)
	ReadByApplicationAliasUnsafe(applicationAlias string) (contextAliasEntry []ContextAliasEntry)
}

// DAOImpl - a container for all information needed to access a DynamoDB table
type DAOImpl struct {
	Dynamo    *awsutils.DynamoRequest `json:"dynamo"`
	Namespace string                  `json:"namespace"`
	Name      string                  `json:"name"`
}

// NewDAO creates an instance of DAO that will provide access to the table
func NewDAO(dynamo *awsutils.DynamoRequest, namespace, clientID string) DAO {
	if clientID == "" { panic("Cannot create DAO without clientID") }
	return DAOImpl{Dynamo: dynamo, Namespace: namespace, 
		Name: clientID + "_context_alias_entry",
	}
}

// NewDAOByTableName creates an instance of DAO that will provide access to the table
func NewDAOByTableName(dynamo *awsutils.DynamoRequest, namespace, tableName string) DAO {
	if tableName == "" { panic("Cannot create DAO without tableName") }
	return DAOImpl{Dynamo: dynamo, Namespace: namespace, 
		Name: tableName,
	}
}

// Create saves the ContextAliasEntry.
func (d DAOImpl) Create(contextAliasEntry ContextAliasEntry) error {
	emptyFields, ok := contextAliasEntry.CollectEmptyFields()
	if !ok {return fmt.Errorf("Cannot create entity with empty fields: %v", emptyFields)}
	return d.Dynamo.PutTableEntry(contextAliasEntry, d.Name)
}


// CreateUnsafe saves the ContextAliasEntry.
func (d DAOImpl) CreateUnsafe(contextAliasEntry ContextAliasEntry) {
	err := d.Create(contextAliasEntry)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Could not create applicationAlias==%s in %s\n", contextAliasEntry.ApplicationAlias, d.Name))
}


// Read reads ContextAliasEntry
func (d DAOImpl) Read(applicationAlias string) (out ContextAliasEntry, err error) {
	var outs []ContextAliasEntry
	outs, err = d.ReadOrEmpty(applicationAlias)
	if err == nil && len(outs) == 0 {
		err = fmt.Errorf("Not found applicationAlias==%s in %s\n", applicationAlias, d.Name)
	}
	return
}


// ReadUnsafe reads the ContextAliasEntry. Panics in case of any errors
func (d DAOImpl) ReadUnsafe(applicationAlias string) ContextAliasEntry {
	out, err := d.Read(applicationAlias)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Error reading applicationAlias==%s in %s\n", applicationAlias, d.Name))
	return out
}


// ReadOrEmpty reads ContextAliasEntry
func (d DAOImpl) ReadOrEmpty(applicationAlias string) (out []ContextAliasEntry, err error) {
	var outOrEmpty ContextAliasEntry
	ids := idParams(applicationAlias)
	err = d.Dynamo.QueryTable(d.Name, ids, &outOrEmpty)
	if outOrEmpty.ApplicationAlias == applicationAlias {
		out = append(out, outOrEmpty)
	}
	err = errors.Wrapf(err, "ContextAliasEntry DAO.ReadOrEmpty(id = %v) couldn't GetItem in table %s", ids, d.Name)
	return
}


// ReadOrEmptyUnsafe reads the ContextAliasEntry. Panics in case of any errors
func (d DAOImpl) ReadOrEmptyUnsafe(applicationAlias string) []ContextAliasEntry {
	out, err := d.ReadOrEmpty(applicationAlias)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Error while reading applicationAlias==%s in %s\n", applicationAlias, d.Name))
	return out
}


// CreateOrUpdate saves the ContextAliasEntry regardless of if it exists.
func (d DAOImpl) CreateOrUpdate(contextAliasEntry ContextAliasEntry) (err error) {
	
	var olds []ContextAliasEntry
	olds, err = d.ReadOrEmpty(contextAliasEntry.ApplicationAlias)
	if err == nil {
		if len(olds) == 0 {
			err = d.Create(contextAliasEntry)
			err = errors.Wrapf(err, "ContextAliasEntry DAO.CreateOrUpdate couldn't Create in table %s", d.Name)
		} else {
			old := olds[0]
			ids := idParams(old.ApplicationAlias)
			err = d.Dynamo.UpdateTableEntry(
				allParams(contextAliasEntry, old),
				ids,
				updateExpression(contextAliasEntry, old),
				d.Name,
			)
			err = errors.Wrapf(err, "ContextAliasEntry DAO.CreateOrUpdate(id = %v) couldn't UpdateTableEntry in table %s", ids, d.Name)
		}
	}
	return 
}


// CreateOrUpdateUnsafe saves the ContextAliasEntry regardless of if it exists.
func (d DAOImpl) CreateOrUpdateUnsafe(contextAliasEntry ContextAliasEntry) {
	err := d.CreateOrUpdate(contextAliasEntry)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("could not create or update %v in %s\n", contextAliasEntry, d.Name))
}


// Delete removes ContextAliasEntry from db
func (d DAOImpl)Delete(applicationAlias string) error {
	return d.Dynamo.DeleteEntry(d.Name, idParams(applicationAlias))
}


// DeleteUnsafe deletes ContextAliasEntry and panics in case of errors.
func (d DAOImpl)DeleteUnsafe(applicationAlias string) {
	err := d.Delete(applicationAlias)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Could not delete applicationAlias==%s in %s\n", applicationAlias, d.Name))
}


func (d DAOImpl)ReadByApplicationAlias(applicationAlias string) (out []ContextAliasEntry, err error) {
	var instances []ContextAliasEntry
	err = d.Dynamo.QueryTableWithIndex(d.Name, awsutils.DynamoIndexExpression{
		IndexName: "ApplicationAliasIndex",
		Condition: "application_alias = :a0",
		Attributes: map[string]interface{}{
			":a0": applicationAlias,
		},
	}, map[string]string{}, true, -1, &instances)
	out = instances
	return
}


func (d DAOImpl)ReadByApplicationAliasUnsafe(applicationAlias string) (out []ContextAliasEntry) {
	out, err := d.ReadByApplicationAlias(applicationAlias)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Could not query ApplicationAliasIndex on %s table\n", d.Name))
	return
}

func idParams(applicationAlias string) map[string]*dynamodb.AttributeValue {
	params := map[string]*dynamodb.AttributeValue {
		"application_alias": common.DynS(applicationAlias),
	}
	return params
}
func allParams(contextAliasEntry ContextAliasEntry, old ContextAliasEntry) (params map[string]*dynamodb.AttributeValue) {
	
		params = map[string]*dynamodb.AttributeValue{}
		if contextAliasEntry.ApplicationAlias != old.ApplicationAlias { params["a0"] = common.DynS(contextAliasEntry.ApplicationAlias) }
		if contextAliasEntry.Context != old.Context { params["a1"] = common.DynS(contextAliasEntry.Context) }
		if contextAliasEntry.BuildID != old.BuildID { params["a2"] = common.DynS(contextAliasEntry.BuildID) }
	return
}
func updateExpression(contextAliasEntry ContextAliasEntry, old ContextAliasEntry) string {
	var updateParts []string
	
		
			
		if contextAliasEntry.ApplicationAlias != old.ApplicationAlias { updateParts = append(updateParts, "application_alias = :a0") }
		if contextAliasEntry.Context != old.Context { updateParts = append(updateParts, "context = :a1") }
		if contextAliasEntry.BuildID != old.BuildID { updateParts = append(updateParts, "build_id = :a2") }
	return strings.Join(updateParts, " and ")
}
