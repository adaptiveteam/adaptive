package coachingRelationship
// This file has been automatically generated by `adaptive-platform/scripts`
// The changes will be overridden by the next automatic generation.
import (
	awsutils "github.com/adaptiveteam/aws-utils-go"
	common "github.com/adaptiveteam/daos/common"
	core "github.com/adaptiveteam/core-utils-go"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/pkg/errors"
	"fmt"
	"strings"
)

type CoachingRelationship struct  {
	CoachQuarterYear string `json:"coach_quarter_year"`
	CoacheeQuarterYear string `json:"coachee_quarter_year"`
	Coachee string `json:"coachee"`
	Quarter int `json:"quarter"`
	Year int `json:"year"`
	CoachRequested bool `json:"coach_requested"`
	CoacheeRequested bool `json:"coachee_requested"`
}

// CollectEmptyFields returns entity field names that are empty.
// It also returns the boolean ok-flag if the list is empty.
func (coachingRelationship CoachingRelationship)CollectEmptyFields() (emptyFields []string, ok bool) {
	if coachingRelationship.CoachQuarterYear == "" { emptyFields = append(emptyFields, "CoachQuarterYear")}
	if coachingRelationship.CoacheeQuarterYear == "" { emptyFields = append(emptyFields, "CoacheeQuarterYear")}
	if coachingRelationship.Coachee == "" { emptyFields = append(emptyFields, "Coachee")}
	ok = len(emptyFields) == 0
	return
}

type DAO interface {
	Create(coachingRelationship CoachingRelationship) error
	CreateUnsafe(coachingRelationship CoachingRelationship)
	Read(coachQuarterYear string) (coachingRelationship CoachingRelationship, err error)
	ReadUnsafe(coachQuarterYear string) (coachingRelationship CoachingRelationship)
	ReadOrEmpty(coachQuarterYear string) (coachingRelationship []CoachingRelationship, err error)
	ReadOrEmptyUnsafe(coachQuarterYear string) (coachingRelationship []CoachingRelationship)
	CreateOrUpdate(coachingRelationship CoachingRelationship) error
	CreateOrUpdateUnsafe(coachingRelationship CoachingRelationship)
	Delete(coachQuarterYear string) error
	DeleteUnsafe(coachQuarterYear string)
	ReadByCoachQuarterYearCoachee(coachQuarterYear string, coachee string) (coachingRelationship []CoachingRelationship, err error)
	ReadByCoachQuarterYearCoacheeUnsafe(coachQuarterYear string, coachee string) (coachingRelationship []CoachingRelationship)
	ReadByCoachQuarterYear(coachQuarterYear string) (coachingRelationship []CoachingRelationship, err error)
	ReadByCoachQuarterYearUnsafe(coachQuarterYear string) (coachingRelationship []CoachingRelationship)
	ReadByQuarterYear(quarter int, year int) (coachingRelationship []CoachingRelationship, err error)
	ReadByQuarterYearUnsafe(quarter int, year int) (coachingRelationship []CoachingRelationship)
	ReadByCoacheeQuarterYear(coacheeQuarterYear string) (coachingRelationship []CoachingRelationship, err error)
	ReadByCoacheeQuarterYearUnsafe(coacheeQuarterYear string) (coachingRelationship []CoachingRelationship)
}

// DAOImpl - a container for all information needed to access a DynamoDB table
type DAOImpl struct {
	Dynamo    *awsutils.DynamoRequest `json:"dynamo"`
	Namespace string                  `json:"namespace"`
	Name      string                  `json:"name"`
}

// NewDAO creates an instance of DAO that will provide access to the table
func NewDAO(dynamo *awsutils.DynamoRequest, namespace, clientID string) DAO {
	if clientID == "" { panic("Cannot create DAO without clientID") }
	return DAOImpl{Dynamo: dynamo, Namespace: namespace, 
		Name: clientID + "_coaching_relationship",
	}
}

// NewDAOByTableName creates an instance of DAO that will provide access to the table
func NewDAOByTableName(dynamo *awsutils.DynamoRequest, namespace, tableName string) DAO {
	if tableName == "" { panic("Cannot create DAO without tableName") }
	return DAOImpl{Dynamo: dynamo, Namespace: namespace, 
		Name: tableName,
	}
}

// Create saves the CoachingRelationship.
func (d DAOImpl) Create(coachingRelationship CoachingRelationship) error {
	emptyFields, ok := coachingRelationship.CollectEmptyFields()
	if !ok {return fmt.Errorf("Cannot create entity with empty fields: %v", emptyFields)}
	return d.Dynamo.PutTableEntry(coachingRelationship, d.Name)
}


// CreateUnsafe saves the CoachingRelationship.
func (d DAOImpl) CreateUnsafe(coachingRelationship CoachingRelationship) {
	err := d.Create(coachingRelationship)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Could not create coachQuarterYear==%s in %s\n", coachingRelationship.CoachQuarterYear, d.Name))
}


// Read reads CoachingRelationship
func (d DAOImpl) Read(coachQuarterYear string) (out CoachingRelationship, err error) {
	var outs []CoachingRelationship
	outs, err = d.ReadOrEmpty(coachQuarterYear)
	if err == nil && len(outs) == 0 {
		err = fmt.Errorf("Not found coachQuarterYear==%s in %s\n", coachQuarterYear, d.Name)
	}
	return
}


// ReadUnsafe reads the CoachingRelationship. Panics in case of any errors
func (d DAOImpl) ReadUnsafe(coachQuarterYear string) CoachingRelationship {
	out, err := d.Read(coachQuarterYear)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Error reading coachQuarterYear==%s in %s\n", coachQuarterYear, d.Name))
	return out
}


// ReadOrEmpty reads CoachingRelationship
func (d DAOImpl) ReadOrEmpty(coachQuarterYear string) (out []CoachingRelationship, err error) {
	var outOrEmpty CoachingRelationship
	ids := idParams(coachQuarterYear)
	err = d.Dynamo.QueryTable(d.Name, ids, &outOrEmpty)
	if outOrEmpty.CoachQuarterYear == coachQuarterYear {
		out = append(out, outOrEmpty)
	}
	err = errors.Wrapf(err, "CoachingRelationship DAO.ReadOrEmpty(id = %v) couldn't GetItem in table %s", ids, d.Name)
	return
}


// ReadOrEmptyUnsafe reads the CoachingRelationship. Panics in case of any errors
func (d DAOImpl) ReadOrEmptyUnsafe(coachQuarterYear string) []CoachingRelationship {
	out, err := d.ReadOrEmpty(coachQuarterYear)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Error while reading coachQuarterYear==%s in %s\n", coachQuarterYear, d.Name))
	return out
}


// CreateOrUpdate saves the CoachingRelationship regardless of if it exists.
func (d DAOImpl) CreateOrUpdate(coachingRelationship CoachingRelationship) (err error) {
	
	var olds []CoachingRelationship
	olds, err = d.ReadOrEmpty(coachingRelationship.CoachQuarterYear)
	if err == nil {
		if len(olds) == 0 {
			err = d.Create(coachingRelationship)
			err = errors.Wrapf(err, "CoachingRelationship DAO.CreateOrUpdate couldn't Create in table %s", d.Name)
		} else {
			old := olds[0]
			ids := idParams(old.CoachQuarterYear)
			err = d.Dynamo.UpdateTableEntry(
				allParams(coachingRelationship, old),
				ids,
				updateExpression(coachingRelationship, old),
				d.Name,
			)
			err = errors.Wrapf(err, "CoachingRelationship DAO.CreateOrUpdate(id = %v) couldn't UpdateTableEntry in table %s", ids, d.Name)
		}
	}
	return 
}


// CreateOrUpdateUnsafe saves the CoachingRelationship regardless of if it exists.
func (d DAOImpl) CreateOrUpdateUnsafe(coachingRelationship CoachingRelationship) {
	err := d.CreateOrUpdate(coachingRelationship)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("could not create or update %v in %s\n", coachingRelationship, d.Name))
}


// Delete removes CoachingRelationship from db
func (d DAOImpl)Delete(coachQuarterYear string) error {
	return d.Dynamo.DeleteEntry(d.Name, idParams(coachQuarterYear))
}


// DeleteUnsafe deletes CoachingRelationship and panics in case of errors.
func (d DAOImpl)DeleteUnsafe(coachQuarterYear string) {
	err := d.Delete(coachQuarterYear)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Could not delete coachQuarterYear==%s in %s\n", coachQuarterYear, d.Name))
}


func (d DAOImpl)ReadByCoachQuarterYearCoachee(coachQuarterYear string, coachee string) (out []CoachingRelationship, err error) {
	var instances []CoachingRelationship
	err = d.Dynamo.QueryTableWithIndex(d.Name, awsutils.DynamoIndexExpression{
		IndexName: "CoachQuarterYearCoacheeIndex",
		Condition: "coach_quarter_year = :a0 and coachee = :a1",
		Attributes: map[string]interface{}{
			":a0": coachQuarterYear,
			":a1": coachee,
		},
	}, map[string]string{}, true, -1, &instances)
	out = instances
	return
}


func (d DAOImpl)ReadByCoachQuarterYearCoacheeUnsafe(coachQuarterYear string, coachee string) (out []CoachingRelationship) {
	out, err := d.ReadByCoachQuarterYearCoachee(coachQuarterYear, coachee)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Could not query CoachQuarterYearCoacheeIndex on %s table\n", d.Name))
	return
}


func (d DAOImpl)ReadByCoachQuarterYear(coachQuarterYear string) (out []CoachingRelationship, err error) {
	var instances []CoachingRelationship
	err = d.Dynamo.QueryTableWithIndex(d.Name, awsutils.DynamoIndexExpression{
		IndexName: "CoachQuarterYearIndex",
		Condition: "coach_quarter_year = :a0",
		Attributes: map[string]interface{}{
			":a0": coachQuarterYear,
		},
	}, map[string]string{}, true, -1, &instances)
	out = instances
	return
}


func (d DAOImpl)ReadByCoachQuarterYearUnsafe(coachQuarterYear string) (out []CoachingRelationship) {
	out, err := d.ReadByCoachQuarterYear(coachQuarterYear)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Could not query CoachQuarterYearIndex on %s table\n", d.Name))
	return
}


func (d DAOImpl)ReadByQuarterYear(quarter int, year int) (out []CoachingRelationship, err error) {
	var instances []CoachingRelationship
	err = d.Dynamo.QueryTableWithIndex(d.Name, awsutils.DynamoIndexExpression{
		IndexName: "QuarterYearIndex",
		Condition: "quarter = :a0 and #year = :a1",
		Attributes: map[string]interface{}{
			":a0": quarter,
			":a1": year,
		},
	}, map[string]string{"#year": "year"}, true, -1, &instances)
	out = instances
	return
}


func (d DAOImpl)ReadByQuarterYearUnsafe(quarter int, year int) (out []CoachingRelationship) {
	out, err := d.ReadByQuarterYear(quarter, year)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Could not query QuarterYearIndex on %s table\n", d.Name))
	return
}


func (d DAOImpl)ReadByCoacheeQuarterYear(coacheeQuarterYear string) (out []CoachingRelationship, err error) {
	var instances []CoachingRelationship
	err = d.Dynamo.QueryTableWithIndex(d.Name, awsutils.DynamoIndexExpression{
		IndexName: "CoacheeQuarterYearIndex",
		Condition: "coachee_quarter_year = :a0",
		Attributes: map[string]interface{}{
			":a0": coacheeQuarterYear,
		},
	}, map[string]string{}, true, -1, &instances)
	out = instances
	return
}


func (d DAOImpl)ReadByCoacheeQuarterYearUnsafe(coacheeQuarterYear string) (out []CoachingRelationship) {
	out, err := d.ReadByCoacheeQuarterYear(coacheeQuarterYear)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Could not query CoacheeQuarterYearIndex on %s table\n", d.Name))
	return
}

func idParams(coachQuarterYear string) map[string]*dynamodb.AttributeValue {
	params := map[string]*dynamodb.AttributeValue {
		"coach_quarter_year": common.DynS(coachQuarterYear),
	}
	return params
}
func allParams(coachingRelationship CoachingRelationship, old CoachingRelationship) (params map[string]*dynamodb.AttributeValue) {
	
		params = map[string]*dynamodb.AttributeValue{}
		if coachingRelationship.CoachQuarterYear != old.CoachQuarterYear { params["a0"] = common.DynS(coachingRelationship.CoachQuarterYear) }
		if coachingRelationship.CoacheeQuarterYear != old.CoacheeQuarterYear { params["a1"] = common.DynS(coachingRelationship.CoacheeQuarterYear) }
		if coachingRelationship.Coachee != old.Coachee { params["a2"] = common.DynS(coachingRelationship.Coachee) }
		if coachingRelationship.Quarter != old.Quarter { params["a3"] = common.DynN(coachingRelationship.Quarter) }
		if coachingRelationship.Year != old.Year { params["a4"] = common.DynN(coachingRelationship.Year) }
		if coachingRelationship.CoachRequested != old.CoachRequested { params["a5"] = common.DynBOOL(coachingRelationship.CoachRequested) }
		if coachingRelationship.CoacheeRequested != old.CoacheeRequested { params["a6"] = common.DynBOOL(coachingRelationship.CoacheeRequested) }
	return
}
func updateExpression(coachingRelationship CoachingRelationship, old CoachingRelationship) string {
	var updateParts []string
	
		
			
		if coachingRelationship.CoachQuarterYear != old.CoachQuarterYear { updateParts = append(updateParts, "coach_quarter_year = :a0") }
		if coachingRelationship.CoacheeQuarterYear != old.CoacheeQuarterYear { updateParts = append(updateParts, "coachee_quarter_year = :a1") }
		if coachingRelationship.Coachee != old.Coachee { updateParts = append(updateParts, "coachee = :a2") }
		if coachingRelationship.Quarter != old.Quarter { updateParts = append(updateParts, "quarter = :a3") }
		if coachingRelationship.Year != old.Year { updateParts = append(updateParts, "#year = :a4") }
		if coachingRelationship.CoachRequested != old.CoachRequested { updateParts = append(updateParts, "coach_requested = :a5") }
		if coachingRelationship.CoacheeRequested != old.CoacheeRequested { updateParts = append(updateParts, "coachee_requested = :a6") }
	return strings.Join(updateParts, " and ")
}
