package strategyCommunity
// This file has been automatically generated by `adaptive-platform/scripts`
// The changes will be overridden by the next automatic generation.
import (
	"github.com/adaptiveteam/adaptive-utils-go/models"
	"time"
	awsutils "github.com/adaptiveteam/aws-utils-go"
	common "github.com/adaptiveteam/daos/common"
	core "github.com/adaptiveteam/core-utils-go"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/pkg/errors"
	"fmt"
	"strings"
)

type AdaptiveCommunityID string

type StrategyCommunity struct  {
	ID string `json:"id"`
	PlatformID models.PlatformID `json:"platform_id"`
	Advocate string `json:"advocate"`
	Community AdaptiveCommunityID `json:"community"`
	ChannelID string `json:"channel_id"`
	// 0 for false
	ChannelCreated int `json:"channel_created"`
	AccountabilityPartner string `json:"accountability_partner"`
	ParentCommunity AdaptiveCommunityID `json:"parent_community"`
	ParentCommunityChannelID string `json:"parent_community_channel_id"`
	// Automatically maintained field
	CreatedAt string `json:"created_at"`
	// Automatically maintained field
	ModifiedAt string `json:"modified_at"`
}

// CollectEmptyFields returns entity field names that are empty.
// It also returns the boolean ok-flag if the list is empty.
func (strategyCommunity StrategyCommunity)CollectEmptyFields() (emptyFields []string, ok bool) {
	if strategyCommunity.ID == "" { emptyFields = append(emptyFields, "ID")}
	if strategyCommunity.PlatformID == "" { emptyFields = append(emptyFields, "PlatformID")}
	if strategyCommunity.Advocate == "" { emptyFields = append(emptyFields, "Advocate")}
	if strategyCommunity.ChannelID == "" { emptyFields = append(emptyFields, "ChannelID")}
	if strategyCommunity.AccountabilityPartner == "" { emptyFields = append(emptyFields, "AccountabilityPartner")}
	if strategyCommunity.ParentCommunityChannelID == "" { emptyFields = append(emptyFields, "ParentCommunityChannelID")}
	ok = len(emptyFields) == 0
	return
}

type DAO interface {
	Create(strategyCommunity StrategyCommunity) error
	CreateUnsafe(strategyCommunity StrategyCommunity)
	Read(id string) (strategyCommunity StrategyCommunity, err error)
	ReadUnsafe(id string) (strategyCommunity StrategyCommunity)
	ReadOrEmpty(id string) (strategyCommunity []StrategyCommunity, err error)
	ReadOrEmptyUnsafe(id string) (strategyCommunity []StrategyCommunity)
	CreateOrUpdate(strategyCommunity StrategyCommunity) error
	CreateOrUpdateUnsafe(strategyCommunity StrategyCommunity)
	Delete(id string) error
	DeleteUnsafe(id string)
	ReadByID(id string) (strategyCommunity []StrategyCommunity, err error)
	ReadByIDUnsafe(id string) (strategyCommunity []StrategyCommunity)
	ReadByPlatformIDChannelCreated(platformID models.PlatformID, channelCreated int) (strategyCommunity []StrategyCommunity, err error)
	ReadByPlatformIDChannelCreatedUnsafe(platformID models.PlatformID, channelCreated int) (strategyCommunity []StrategyCommunity)
	ReadByPlatformID(platformID models.PlatformID) (strategyCommunity []StrategyCommunity, err error)
	ReadByPlatformIDUnsafe(platformID models.PlatformID) (strategyCommunity []StrategyCommunity)
	ReadByChannelID(channelID string) (strategyCommunity []StrategyCommunity, err error)
	ReadByChannelIDUnsafe(channelID string) (strategyCommunity []StrategyCommunity)
}

// DAOImpl - a container for all information needed to access a DynamoDB table
type DAOImpl struct {
	Dynamo    *awsutils.DynamoRequest `json:"dynamo"`
	Namespace string                  `json:"namespace"`
	Name      string                  `json:"name"`
}

// NewDAO creates an instance of DAO that will provide access to the table
func NewDAO(dynamo *awsutils.DynamoRequest, namespace, clientID string) DAO {
	if clientID == "" { panic("Cannot create DAO without clientID") }
	return DAOImpl{Dynamo: dynamo, Namespace: namespace, 
		Name: clientID + "_strategy_community",
	}
}

// NewDAOByTableName creates an instance of DAO that will provide access to the table
func NewDAOByTableName(dynamo *awsutils.DynamoRequest, namespace, tableName string) DAO {
	if tableName == "" { panic("Cannot create DAO without tableName") }
	return DAOImpl{Dynamo: dynamo, Namespace: namespace, 
		Name: tableName,
	}
}

// Create saves the StrategyCommunity.
func (d DAOImpl) Create(strategyCommunity StrategyCommunity) error {
	emptyFields, ok := strategyCommunity.CollectEmptyFields()
	if !ok {return fmt.Errorf("Cannot create entity with empty fields: %v", emptyFields)}
	strategyCommunity.ModifiedAt = core.TimestampLayout.Format(time.Now())
	strategyCommunity.CreatedAt = strategyCommunity.ModifiedAt
	return d.Dynamo.PutTableEntry(strategyCommunity, d.Name)
}


// CreateUnsafe saves the StrategyCommunity.
func (d DAOImpl) CreateUnsafe(strategyCommunity StrategyCommunity) {
	err := d.Create(strategyCommunity)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Could not create id==%s in %s\n", strategyCommunity.ID, d.Name))
}


// Read reads StrategyCommunity
func (d DAOImpl) Read(id string) (out StrategyCommunity, err error) {
	var outs []StrategyCommunity
	outs, err = d.ReadOrEmpty(id)
	if err == nil && len(outs) == 0 {
		err = fmt.Errorf("Not found id==%s in %s\n", id, d.Name)
	}
	return
}


// ReadUnsafe reads the StrategyCommunity. Panics in case of any errors
func (d DAOImpl) ReadUnsafe(id string) StrategyCommunity {
	out, err := d.Read(id)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Error reading id==%s in %s\n", id, d.Name))
	return out
}


// ReadOrEmpty reads StrategyCommunity
func (d DAOImpl) ReadOrEmpty(id string) (out []StrategyCommunity, err error) {
	var outOrEmpty StrategyCommunity
	ids := idParams(id)
	err = d.Dynamo.QueryTable(d.Name, ids, &outOrEmpty)
	if outOrEmpty.ID == id {
		out = append(out, outOrEmpty)
	}
	err = errors.Wrapf(err, "StrategyCommunity DAO.ReadOrEmpty(id = %v) couldn't GetItem in table %s", ids, d.Name)
	return
}


// ReadOrEmptyUnsafe reads the StrategyCommunity. Panics in case of any errors
func (d DAOImpl) ReadOrEmptyUnsafe(id string) []StrategyCommunity {
	out, err := d.ReadOrEmpty(id)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Error while reading id==%s in %s\n", id, d.Name))
	return out
}


// CreateOrUpdate saves the StrategyCommunity regardless of if it exists.
func (d DAOImpl) CreateOrUpdate(strategyCommunity StrategyCommunity) (err error) {
	strategyCommunity.ModifiedAt = core.TimestampLayout.Format(time.Now())
	if strategyCommunity.CreatedAt == "" { strategyCommunity.CreatedAt = strategyCommunity.ModifiedAt }
	
	var olds []StrategyCommunity
	olds, err = d.ReadOrEmpty(strategyCommunity.ID)
	if err == nil {
		if len(olds) == 0 {
			err = d.Create(strategyCommunity)
			err = errors.Wrapf(err, "StrategyCommunity DAO.CreateOrUpdate couldn't Create in table %s", d.Name)
		} else {
			old := olds[0]
			strategyCommunity.ModifiedAt = core.TimestampLayout.Format(time.Now())
ids := idParams(old.ID)
			err = d.Dynamo.UpdateTableEntry(
				allParams(strategyCommunity, old),
				ids,
				updateExpression(strategyCommunity, old),
				d.Name,
			)
			err = errors.Wrapf(err, "StrategyCommunity DAO.CreateOrUpdate(id = %v) couldn't UpdateTableEntry in table %s", ids, d.Name)
		}
	}
	return 
}


// CreateOrUpdateUnsafe saves the StrategyCommunity regardless of if it exists.
func (d DAOImpl) CreateOrUpdateUnsafe(strategyCommunity StrategyCommunity) {
	err := d.CreateOrUpdate(strategyCommunity)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("could not create or update %v in %s\n", strategyCommunity, d.Name))
}


// Delete removes StrategyCommunity from db
func (d DAOImpl)Delete(id string) error {
	return d.Dynamo.DeleteEntry(d.Name, idParams(id))
}


// DeleteUnsafe deletes StrategyCommunity and panics in case of errors.
func (d DAOImpl)DeleteUnsafe(id string) {
	err := d.Delete(id)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Could not delete id==%s in %s\n", id, d.Name))
}


func (d DAOImpl)ReadByID(id string) (out []StrategyCommunity, err error) {
	var instances []StrategyCommunity
	err = d.Dynamo.QueryTableWithIndex(d.Name, awsutils.DynamoIndexExpression{
		IndexName: "IDIndex",
		Condition: "id = :a0",
		Attributes: map[string]interface{}{
			":a0": id,
		},
	}, map[string]string{}, true, -1, &instances)
	out = instances
	return
}


func (d DAOImpl)ReadByIDUnsafe(id string) (out []StrategyCommunity) {
	out, err := d.ReadByID(id)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Could not query IDIndex on %s table\n", d.Name))
	return
}


func (d DAOImpl)ReadByPlatformIDChannelCreated(platformID models.PlatformID, channelCreated int) (out []StrategyCommunity, err error) {
	var instances []StrategyCommunity
	err = d.Dynamo.QueryTableWithIndex(d.Name, awsutils.DynamoIndexExpression{
		IndexName: "PlatformIDChannelCreatedIndex",
		Condition: "platform_id = :a0 and channel_created = :a1",
		Attributes: map[string]interface{}{
			":a0": platformID,
			":a1": channelCreated,
		},
	}, map[string]string{}, true, -1, &instances)
	out = instances
	return
}


func (d DAOImpl)ReadByPlatformIDChannelCreatedUnsafe(platformID models.PlatformID, channelCreated int) (out []StrategyCommunity) {
	out, err := d.ReadByPlatformIDChannelCreated(platformID, channelCreated)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Could not query PlatformIDChannelCreatedIndex on %s table\n", d.Name))
	return
}


func (d DAOImpl)ReadByPlatformID(platformID models.PlatformID) (out []StrategyCommunity, err error) {
	var instances []StrategyCommunity
	err = d.Dynamo.QueryTableWithIndex(d.Name, awsutils.DynamoIndexExpression{
		IndexName: "PlatformIDIndex",
		Condition: "platform_id = :a0",
		Attributes: map[string]interface{}{
			":a0": platformID,
		},
	}, map[string]string{}, true, -1, &instances)
	out = instances
	return
}


func (d DAOImpl)ReadByPlatformIDUnsafe(platformID models.PlatformID) (out []StrategyCommunity) {
	out, err := d.ReadByPlatformID(platformID)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Could not query PlatformIDIndex on %s table\n", d.Name))
	return
}


func (d DAOImpl)ReadByChannelID(channelID string) (out []StrategyCommunity, err error) {
	var instances []StrategyCommunity
	err = d.Dynamo.QueryTableWithIndex(d.Name, awsutils.DynamoIndexExpression{
		IndexName: "ChannelIDIndex",
		Condition: "channel_id = :a0",
		Attributes: map[string]interface{}{
			":a0": channelID,
		},
	}, map[string]string{}, true, -1, &instances)
	out = instances
	return
}


func (d DAOImpl)ReadByChannelIDUnsafe(channelID string) (out []StrategyCommunity) {
	out, err := d.ReadByChannelID(channelID)
	core.ErrorHandler(err, d.Namespace, fmt.Sprintf("Could not query ChannelIDIndex on %s table\n", d.Name))
	return
}

func idParams(id string) map[string]*dynamodb.AttributeValue {
	params := map[string]*dynamodb.AttributeValue {
		"id": common.DynS(id),
	}
	return params
}
func allParams(strategyCommunity StrategyCommunity, old StrategyCommunity) (params map[string]*dynamodb.AttributeValue) {
	
		params = map[string]*dynamodb.AttributeValue{}
		if strategyCommunity.ID != old.ID { params["a0"] = common.DynS(strategyCommunity.ID) }
		if strategyCommunity.PlatformID != old.PlatformID { params["a1"] = common.DynS(string(strategyCommunity.PlatformID)) }
		if strategyCommunity.Advocate != old.Advocate { params["a2"] = common.DynS(strategyCommunity.Advocate) }
		if strategyCommunity.Community != old.Community { params["a3"] = common.DynS(string(strategyCommunity.Community)) }
		if strategyCommunity.ChannelID != old.ChannelID { params["a4"] = common.DynS(strategyCommunity.ChannelID) }
		if strategyCommunity.ChannelCreated != old.ChannelCreated { params["a5"] = common.DynN(strategyCommunity.ChannelCreated) }
		if strategyCommunity.AccountabilityPartner != old.AccountabilityPartner { params["a6"] = common.DynS(strategyCommunity.AccountabilityPartner) }
		if strategyCommunity.ParentCommunity != old.ParentCommunity { params["a7"] = common.DynS(string(strategyCommunity.ParentCommunity)) }
		if strategyCommunity.ParentCommunityChannelID != old.ParentCommunityChannelID { params["a8"] = common.DynS(strategyCommunity.ParentCommunityChannelID) }
		if strategyCommunity.CreatedAt != old.CreatedAt { params["a9"] = common.DynS(strategyCommunity.CreatedAt) }
		if strategyCommunity.ModifiedAt != old.ModifiedAt { params["a10"] = common.DynS(strategyCommunity.ModifiedAt) }
	return
}
func updateExpression(strategyCommunity StrategyCommunity, old StrategyCommunity) string {
	var updateParts []string
	
		
			
		if strategyCommunity.ID != old.ID { updateParts = append(updateParts, "id = :a0") }
		if strategyCommunity.PlatformID != old.PlatformID { updateParts = append(updateParts, "platform_id = :a1") }
		if strategyCommunity.Advocate != old.Advocate { updateParts = append(updateParts, "advocate = :a2") }
		if strategyCommunity.Community != old.Community { updateParts = append(updateParts, "community = :a3") }
		if strategyCommunity.ChannelID != old.ChannelID { updateParts = append(updateParts, "channel_id = :a4") }
		if strategyCommunity.ChannelCreated != old.ChannelCreated { updateParts = append(updateParts, "channel_created = :a5") }
		if strategyCommunity.AccountabilityPartner != old.AccountabilityPartner { updateParts = append(updateParts, "accountability_partner = :a6") }
		if strategyCommunity.ParentCommunity != old.ParentCommunity { updateParts = append(updateParts, "parent_community = :a7") }
		if strategyCommunity.ParentCommunityChannelID != old.ParentCommunityChannelID { updateParts = append(updateParts, "parent_community_channel_id = :a8") }
		if strategyCommunity.CreatedAt != old.CreatedAt { updateParts = append(updateParts, "created_at = :a9") }
		if strategyCommunity.ModifiedAt != old.ModifiedAt { updateParts = append(updateParts, "modified_at = :a10") }
	return strings.Join(updateParts, " and ")
}
